### Аналіз порушення LSP у початковій ієрархії

**Liskov Substitution Principle** стверджує, що об'єкти базового класу мають бути замінюваними об'єктами похідних класів без зміни коректності програми.

1. Проблема: Клас `GuestUser` наслідується від User, успадковуючи метод ChangePassword.

2. Порушення контракту: Базовий клас `User` декларує, що зміна пароля — це валідна операція. `GuestUser` порушує цей контракт, викидаючи `UnauthorizedAccessException`.

3. Наслідки: Клієнтський код (метод `ProcessUser`), який працює з типом User, "падає" при отриманні гостя. Це змушує розробника додавати перевірки типу (`if user is GuestUser`), що порушує ще й принцип Open/Closed.

### Опис рефакторингу

Для виправлення було обрано підхід "Зміна ієрархії та використання інтерфейсів".

Що зроблено: Ми виділили спільну поведінку (ім'я, опис) в абстрактний клас `BaseAccount`. Можливість зміни пароля винесена в окремий інтерфейс `IPasswordChangeable`.

Чому це працює: `GuestAccount` тепер не має методу `ChangePassword` взагалі, тому ми не зможемо викликати його випадково.

Клієнтський метод `UpdatePasswordSafe` тепер вимагає не просто "користувача", а об'єкт, що реалізує `IPasswordChangeable`.

Принцип підстановки тепер дотримується: будь-яка реалізація `IPasswordChangeable` дійсно може змінити пароль.

### Висновок

Дотримання LSP дозволяє створювати передбачувані ієрархії класів. Замість того, щоб намагатися "втиснути" невідповідну поведінку в спадковість (що часто призводить до `NotImplementedException`), краще розділити інтерфейси за функціоналом. Це робить код безпечнішим, оскільки помилки виявляються ще на етапі компиляції, а не під час виконання програми.
