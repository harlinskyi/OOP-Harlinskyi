# Звіт про Самостійну Роботу: Узагальнений Кеш `Cache<T>`

## Тема: Generics та Обмеження (Constraints) у C#

| Параметр | Значення |
| :--- | :--- |
| **Розроблений клас** | `Cache<T>` |
| **Обмеження (Constraints)** | `where T : class, new()` (Посилальний тип та конструктор без параметрів) |
| **Внутрішній об'єкт** | `CacheItem` (зберігає значення `T Value` та `DateTime AddedTime`) |

---

## Реалізовані Алгоритми

### 1. Алгоритм Видалення Старих Елементів (`CleanUpOldest()`)

**Мета:** Підтримка максимального розміру кешу (`_maxSize`).

**Принцип:** Якщо кількість елементів перевищує `_maxSize`, виконується ітеративний пошук елемента з **мінімальним** значенням `AddedTime` (найстарішого). Цей елемент **видаляється** зі списку.

**Стратегія:** Ефективна реалізація політики витіснення **FIFO (First-In, First-Out)** або LRU (Least Recently Used) за часом додавання.

---

### 2. Алгоритм Сортування (`SortCacheItemsByTime()`)

**Мета:** Сортування внутрішнього списку елементів **без використання** методів `Linq.Sort` чи `List.Sort`.

**Використаний алгоритм:** **Сортування Вибором (Selection Sort)**.

**Принцип:** Сортування здійснюється на основі поля `AddedTime`. На кожному кроці алгоритм знаходить найстаріший елемент у невідсортованій частині і поміщає його на поточну позицію. Це забезпечує сортування від **найстарішого до найновішого** елемента.

---

## Висновок

Робота успішно демонструє використання **узагальнень** C# та застосування необхідних **обмежень**. Обидва ключові алгоритми — **видалення старих елементів** та **сортування** — були реалізовані власноруч, повністю задовольняючи поставлені вимоги.