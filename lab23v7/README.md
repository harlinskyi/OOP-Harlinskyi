### 1. Аналіз коду до рефакторингу

У початковій реалізації (варіант Vehicle Management) були виявлені наступні порушення SOLID:

Порушення DIP (Dependency Inversion Principle): Клас вищого рівня CarComputer безпосередньо створює об'єкти класів нижчого рівня (EngineUnit, RadioTuner, GPSModule) через ключове слово new. Це створює "жорстку залежність": ми не можемо змінити тип двигуна або модель GPS, не переписуючи код самого комп'ютера.

Порушення ISP: Відсутність інтерфейсів призводить до того, що система є монолітною. Якби ми спробували створити загальний інтерфейс для всіх пристроїв авто, класи були б змушені реалізовувати методи, які їм не потрібні (наприклад, двигуну не потрібен метод PlayMusic).

### 2. Опис внесених змін

Під час рефакторингу було зроблено наступне:

Застосування ISP: Створено три вузькоспеціалізовані інтерфейси: IEngine, IRadio, та IGPS. Це гарантує, що класи реалізують лише ту поведінку, яка їм справді необхідна.

Застосування DIP: Клас CarComputer тепер залежить не від конкретних класів, а від інтерфейсів. Це дозволяє підставляти будь-яку реалізацію (наприклад, іншу марку радіо) без зміни логіки комп'ютера.

Реалізація Dependency Injection: Впроваджено передачу залежностей через конструктор. Тепер зовнішній код (Main) керує життєвим циклом об'єктів та передає їх у CarComputer.

### 3. Фрагменти рефакторингового рішення

    Створення інтерфейсів (ISP):
    ```C#
    public interface IEngine { void Start(); }
    public interface IRadio { void Play(); }
    public interface IGPS { void Locate(); }
    ```
    Впровадження через конструктор (DIP/DI):
    ```C#
    public class CarComputer {
    private readonly IEngine \_engine;
    private readonly IRadio \_radio;
    private readonly IGPS \_gps;

        public CarComputer(IEngine engine, IRadio radio, IGPS gps) {
            _engine = engine;
            _radio = radio;
            _gps = gps;
        }

    }
    ```

### 4. Висновки

    В результаті виконання роботи було продемонстровано переваги принципів ISP та DIP.

- Код став більш гнучким: ми можемо легко замінити ModernEngine на ElectricEngine, просто реалізувавши інтерфейс.

- Код став тестованим: ми можемо передати в конструктор "заглушки" (Mock-об'єкти) замість реального заліза.

- Зменшено зв’язаність (coupling) між модулями, що полегшує підтримку та розширення проєкту в майбутньому.
