# Принципи ISP та DIP: Шлях до гнучкої архітектури

У сучасному програмуванні гнучкість коду визначається тим, наскільки легко ми можемо змінювати або замінювати окремі частини системи. **ISP** та **DIP** — це фундамент, який дозволяє будувати модульні та тестовані додатки.

---

## 1. Принцип розділення інтерфейсу (ISP)

**Interface Segregation Principle** стверджує: *Клієнти не повинні залежати від методів, які вони не використовують.* Краще створити кілька вузькоспеціалізованих інтерфейсів, ніж один "товстий" (fat interface).

### Приклад порушення ISP
Уявімо інтерфейс для багатофункціонального пристрою:

```csharp
// Порушення: "Товстий" інтерфейс
public interface ISmartDevice {
    void Print();
    void Fax();
    void Scan();
}

public class EconomicPrinter : ISmartDevice {
    public void Print() { 
        Console.WriteLine("Друкую документ..."); 
    }
    
    // Проблема! Принтер не вміє надсилати факс
    public void Fax() => throw new NotImplementedException(); 
    
    // Проблема! Принтер не має сканера
    public void Scan() => throw new NotImplementedException(); 
}
```

### Вирішення проблеми
Розділяємо один великий інтерфейс на кілька дрібних, що відповідають конкретним ролям:
```csharp
public interface IPrinter { void Print(); }
public interface IFax { void Fax(); }
public interface IScanner { void Scan(); }

// Тепер принтер реалізує лише те, що йому справді потрібно
public class EconomicPrinter : IPrinter {
    public void Print() { 
        Console.WriteLine("Друкую на дешевому принтері..."); 
    }
}

public class AllInOneOfficePro : IPrinter, IScanner, IFax {
    public void Print() { /* логіка */ }
    public void Scan() { /* логіка */ }
    public void Fax() { /* логіка */ }
}
```

## 2. Принцип інверсії залежностей (DIP)
Dependency Inversion Principle каже:
1) Модулі верхнього рівня не повинні залежати від модулів нижнього рівня. Обидва мають залежати від абстракцій.
2) Абстракції не повинні залежати від деталей. Деталі мають залежати від абстракцій.

Переваги застосування DIP через Dependency Injection (DI):
- Слабкий зв'язок (Loose Coupling): Класи взаємодіють через \"контракти\" (інтерфейси), а не конкретні класи.
- Легка заміна логіки: Ви можете змінити SqlDatabase на MongoDatabase або MockDatabase, не змінюючи код бізнес-логіки.
- Централізоване керування: Всі залежності налаштовуються в одному місці (DI-контейнері), що спрощує конфігурацію додатка.

## 3. Синергія ISP та DIP у тестуванні
Вузькі інтерфейси (ISP) є ідеальними партнерами для інверсії залежностей (DIP) з кількох причин:
1) Чистота контракту: Коли клас отримує через конструктор IPrinter, він точно знає, що йому доступний лише метод Print(). Це виключає ризик випадкового виклику непотрібних методів (наприклад, Fax()).
2) Просте Unit-тестування:
    - При створенні Mock-об'єктів вам потрібно імітувати лише 1 метод вузького інтерфейсу замість реалізації 10 методів "товстого" інтерфейсу.
    - Тести стають менш крихкими: зміни в методах сканування ніяк не вплинуть на тести, що перевіряють лише друк.
3) Передбачуваність: Система стає прозорою, а залежності — чітко задекларованими.

### Підсумкова таблиця
| Характеристика | Без ISP та DIP | З ISP та DIP |
|---------|------------------------|----------------|
| Залежність | Класи залежать від конкретних реалізацій | Класи залежать від абстракцій (інтерфейсів) |
| Тестування | Складно створювати Mock-об'єкти | Легко створювати Mock-об'єкти для вузьких інтерфейсів |
| Гнучкість | Важко змінювати реалізації без впливу на клієнтів | Легко змінювати реалізації без впливу на клієнтів |
| Крихкість тестів | Висока: зміни в одному методі можуть зламати багато тестів | Низька: зміни в одному методі не впливають на тести інших методів |

## Висновок
ISP забезпечує створення точних інструментів, а DIP дозволяє правильно підключати ці інструменти до системи. Разом вони роблять код професійним та придатним до тривалої підтримки.
