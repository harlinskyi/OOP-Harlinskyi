## Контрольні питання

### 1. Які типи винятків найчастіше виникають при роботі з файлами та мережею?

При розробці програмного забезпечення найчастіше зустрічаються такі класи винятків:

**При роботі з файловою системою (`System.IO`):**

- **`FileNotFoundException`**: Файл, до якого намагається звернутися програма, не знайдено (наприклад, невірний шлях).
- **`DirectoryNotFoundException`**: Вказана частина шляху до каталогу не існує.
- **`IOException`**: Загальна помилка вводу/виводу. Часто виникає, коли файл вже відкритий іншою програмою (блокування файлу) або диск переповнений.
- **`UnauthorizedAccessException`**: У програми немає прав доступу до файлу чи папки (наприклад, спроба запису у системну директорію).

**При роботі з мережею (`System.Net.Http`, `System.Net.Sockets`):**

- **`HttpRequestException`**: Помилка при виконанні HTTP-запиту (наприклад, сервер повернув код помилки 404 або 500, або DNS не зміг розпізнати хост).
- **`SocketException`**: Помилка на рівні сокетів (наприклад, розрив з'єднання, порт недоступний).
- **`TimeoutException`**: Час очікування відповіді від сервера вичерпано.

---

### 2. Поясніть принцип роботи патерну Retry. Коли його доцільно використовувати?

**Принцип роботи:**
Патерн **Retry** (Повторна спроба) полягає в тому, що програма не зупиняється миттєво після виникнення помилки, а намагається виконати ту ж саму операцію ще кілька разів із певними інтервалами. Якщо одна зі спроб вдала — програма продовжує роботу. Якщо ліміт спроб вичерпано — викидається виняток.

**Коли доцільно використовувати:**
Патерн слід використовувати **лише для тимчасових (transient) помилок**, які, ймовірно, зникнуть через короткий проміжок часу.

- **Приклади:** короткочасна втрата мережі, перевантаження сервера (Throttling/Rate Limiting), блокування файлу антивірусом на долі секунди, таймаути бази даних.
- **Коли НЕ використовувати:** для постійних помилок. Наприклад, якщо файл не існує (`FileNotFound`) або користувач ввів невірний пароль (`401 Unauthorized`), повторні спроби не допоможуть, а лише заберуть час.

---

### 3. Як реалізувати експоненційну затримку між повторними спробами?

Експоненційна затримка (Exponential Backoff) передбачає збільшення часу очікування між кожною наступною спробою в геометричній прогресії. Це дозволяє зменшити навантаження на систему, яка і так працює зі збоями.

**Приклад реалізації в коді:**

```csharp
// attempt - номер поточної спроби (0, 1, 2...)
// initialDelay - початковий час (наприклад, 1 секунда)

double multiplier = Math.Pow(2, attempt);
TimeSpan delay = TimeSpan.FromTicks((long)(initialDelay.Ticks * multiplier));

// Якщо initialDelay = 1 сек:
// Спроба 0: затримка 1 сек
// Спроба 1: затримка 2 сек
// Спроба 2: затримка 4 сек

Thread.Sleep(delay); // Або await Task.Delay(delay) в асинхронному коді
```

### 4. Для чого потрібен делегат shouldRetry у допоміжному класі RetryHelper?

Делегат shouldRetry (типу `Func<Exception, bool>`) необхідний для фільтрації винятків. Він дозволяє гнучко визначати, на які саме помилки треба реагувати повторною спробою, а які треба "пропускати" далі, щоб програма впала одразу.

Навіщо це потрібно: Як згадувалося в п. 2, не всі помилки є тимчасовими. Без `shouldRetry` механізм `Retry` сліпо повторював би спроби навіть при критичних помилках логіки (наприклад, `NullReferenceException` або `ArgumentException`), що є неправильним.

Приклад логіки:

```
// Повторюємо, ТІЛЬКИ якщо це помилка мережі або таймаут.
// Якщо це помилка логіки (наприклад, ділення на нуль) - не повторюємо.
shouldRetry: (exception) =>
    exception is HttpRequestException || exception is TimeoutException
```
